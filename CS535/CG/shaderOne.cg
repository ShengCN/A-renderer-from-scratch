
struct VertexDataInput {
	float4 vertex: POSITION;
	float3 normal: NORMAL;
	float3 color: COLOR;
};

struct VertexDataOutput {
	float4 projv  : POSITION;
	float3 normal: TEXCOORD0;
	float3 vxyz: TEXCOORD1;
	float3 color : COLOR;
};

struct PixelDataOutput {
	float3 color : COLOR;
};

VertexDataOutput VertexMain(VertexDataInput vdi, 
  uniform float4x4 modelViewProj,
  uniform float MR, uniform float3 MC, uniform float Mf) {

  VertexDataOutput ret;

  float3 rdir = normalize(vdi.vertex.xyz - MC);
  float3 Vp = MC + rdir * MR;
  float3 mvertex = vdi.vertex.xyz + (Vp - vdi.vertex.xyz) * Mf;

  ret.projv = mul(modelViewProj, float4(mvertex,1.0f));
  
  
  ret.normal = vdi.normal;
  ret.vxyz = vdi.vertex.xyz;
  ret.color = vdi.color;
  return ret;

}

TRIANGLE void GeometryMain(AttribArray<VertexDataOutput> tverts,
	uniform float4x4 modelViewProj) {

	emitVertex(tverts[0]);
	emitVertex(tverts[1]);
	emitVertex(tverts[2]);
	return;

}


PixelDataOutput FragmentMain(VertexDataOutput pdi, uniform float ka,
	uniform float3 C0, uniform float3 C1) {

  PixelDataOutput ret;
  ret.color = pdi.color;
  return ret;

  // float kaa = 0.2f;
  float3 L = float3(0.0f, 0.0f, 0.0f);
  float3 lv = float3(0.0f, 0.0f, 1.0f);
  float kd = mul(pdi.normal, lv);
  kd = (kd < 0.0f) ? 0.0f : kd;
  float3 mc = float3(1.0f, 0.0f, 0.0f);
  ret.color.rgb = mc * (ka + (1.0f-ka)*kd);

//  ret.color.rgb = (pdi.normal + float3(1.0f, 1.0f, 1.0f))/2.0f;
//  ret.color.rgb = float3(1.0f, 0.0f, 0.0f);

//	ret.color.rgb = float3(0.0f, 0.0f, 0.0f);
	  // ret.color.r = ka;
	
	// ret.color.rgb = float3(0.0f, 0.0f, 0.0f);
	// ret.color.rgb = (C0 + float3(150.0f, 150.0f, 150.0f)) / 30.0f;

    return ret;

}
