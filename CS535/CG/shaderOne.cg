
struct VertexDataInput {
	float4 vertex: POSITION;
	float3 normal: NORMAL;
	float3 color: COLOR;
  float2 texCoord : TEXCOORD;
};

struct VertexDataOutput {
	float4 projv  : POSITION;
	float3 normal: TEXCOORD0;
	float3 vxyz: TEXCOORD1;
	float3 color : COLOR;
  	float2 vtexCoord : TEXCOORD2;
};

struct PixelDataOutput {
	float4 color : COLOR;
};

VertexDataOutput VertexMain(VertexDataInput vdi, 
  uniform float4x4 modelViewProj,
  uniform float Mf) {

  VertexDataOutput ret;

  ret.projv = mul(modelViewProj, vdi.vertex);
  
  ret.normal = vdi.normal;
  ret.vxyz = vdi.vertex.xyz;
  ret.color = vdi.color;
  ret.vtexCoord = vdi.texCoord;
  return ret;

}

TRIANGLE void GeometryMain(AttribArray<VertexDataOutput> tverts,
	uniform float4x4 modelViewProj) {

	emitVertex(tverts[0]);
	emitVertex(tverts[1]);
	emitVertex(tverts[2]);
	return;

}

// do gamma correction
const float gamma = 2.2;
float3 ToLinear(float3 color)
{
	return pow(color,gamma);
}

// -----------------------
// Global Variables:
// Ground plane (float)
// Box0, Box1, Box2 (float3)
// -----------------------
float groundPlaneH;
float roughness = 0.25;
float3 dcolor = float3(1.0);
float3 scolor = float3(0.23);

bool IntersectBB(float3x3 bb, float3 ro, float3 rd, out float t, out float2 uv)
{
	// ray bb intersection
	float3 p0 = bb[0];
	float3 p1 = bb[1];
	float3 p2 = bb[2];
	float3 n = normalize(cross(p1-p0,p2-p0)); 
	t = -dot(ro - p0,n)/dot(rd,n);
	float3 p = ro + t * rd - p0;
	float3 x = p2 - p0;
	float3 y = p1 - p0;
	float u = dot(p,normalize(x)) / length(x);
	float v = dot(p,normalize(y)) / length(y);
	
	// not intersect
	if(u<0.0 || u > 1.0 || v < 0.0 || v > 1.0)
		return false;

	uv[0] = u;
	uv[1] = 1.0 - v;	// OpenGL uv 
	return true;
}

bool IntersectBB(float3x3 bb, float3 ro, float3 rd, out float ot)
{
	// ray bb intersection
	float3 p0 = bb[0];
	float3 p1 = bb[1];
	float3 p2 = bb[2];
	float3 n = normalize(cross(p1-p0,p2-p0)); 
	float t = -dot(ro - p0,n)/dot(rd,n);
	float3 p = ro + t * rd - p0;
	float3 x = p2 - p0;
	float3 y = p1 - p0;
	float u = dot(p,normalize(x)) / length(x);
	float v = dot(p,normalize(y)) / length(y);
	
	// not intersect
	if(u < 0.0 || u > 1.0 || v < 0.0 || v > 1.0)
	{
		return false;
	}

	ot = t;
	return true;
}


PixelDataOutput FragmentMain(VertexDataOutput pdi, 
  uniform float3 ppc_C,
  uniform float groundHeight,	// hard coded 
  uniform int hasST,
  uniform int isCubemap,
  uniform int isGround,
  uniform sampler2D tex,
  uniform samplerCUBE env) {

	// Pass in global variables
	groundPlaneH = groundHeight;

	PixelDataOutput ret;
	
	// floor normal
	float3 floorPlane = float4(0.0,1.0,0.0,0.0); 

	float3 col = float3(0.0);
	float3 pc = ToLinear(pdi.color);
	float alpha = 1.0;

	if(isGround)
	{
		float3 pos = pdi.vxyz;
		float3 N = floorPlane.xyz;
		float3 V = normalize(ppc_C - pdi.vxyz);
		float ndotv = clamp(dot(N,V), 0.0, 1.0);
		col = ndotv;
	}
	else
	{
		col = pc;
	}
	
  	ret.color = float4(clamp(col ,0.0,1.0),alpha);
  	return ret;
}
