
struct VertexDataInput {
	float4 vertex: POSITION;
	float3 normal: NORMAL;
	float3 color: COLOR;
  float2 texCoord : TEXCOORD;
};

struct VertexDataOutput {
	float4 projv  : POSITION;
	float3 normal: TEXCOORD0;
	float3 vxyz: TEXCOORD1;
	float3 color : COLOR;
  float2 vtexCoord : TEXCOORD2;
};

struct PixelDataOutput {
	float4 color : COLOR;
};

VertexDataOutput VertexMain(VertexDataInput vdi, 
  uniform float4x4 modelViewProj,
  uniform float Mf) {

  VertexDataOutput ret;

  ret.projv = mul(modelViewProj, vdi.vertex);
  
  ret.normal = vdi.normal;
  ret.vxyz = vdi.vertex.xyz;
  ret.color = vdi.color;
  ret.vtexCoord = vdi.texCoord;
  return ret;

}

TRIANGLE void GeometryMain(AttribArray<VertexDataOutput> tverts,
	uniform float4x4 modelViewProj) {

	emitVertex(tverts[0]);
	emitVertex(tverts[1]);
	emitVertex(tverts[2]);
	return;

}


PixelDataOutput FragmentMain(VertexDataOutput pdi, 
  uniform float3 light_position,
  uniform float3 ppc_C,
  uniform int hasST,
  uniform sampler2D tex0,
  uniform samplerCUBE env) {

  PixelDataOutput ret;
  
  // Phong Lighting
  float3 viewdir = ppc_C - pdi.vxyz;
  float3 lightdir = light_position - pdi.vxyz;
  float ka = 0.1f;
  float kd = max(0.0f, dot(normalize(lightdir), normalize(pdi.normal)));
  float ks = pow(max(0.0f, dot(reflect(normalize(-lightdir),normalize(pdi.normal)) , normalize(viewdir))), 200);
  
  float3 pc;
  float alpha;

  if(hasST > 0) {
	  float4 texColor = tex2D(tex0, pdi.vtexCoord);
	  // float4 texColor = tex2D(tex0, pdi.vtexCoord);
	  pc = texColor.rgb;
	  alpha = texColor.a;
  }
  else {
  	// try cubemap
	float3 reflectDir = reflect(normalize(viewdir), normalize(pdi.normal));
	pc = texCUBE(env, reflectDir).rgb;
	alpha = 1.0;
	
   }
  // float3 phongColor =  pc * (ka + (1.0f - ka) * kd) + float3(1.0f) * ks;
  ret.color = float4(pc,alpha);

  return ret;

	// BILLBOARD REFLECTIONS

	// create reflected ray at this current pixel

	// eye ray is eye-3D surface point at this current pixel
	//		eye needs to be passed in as uniform float3
	//		3D surface point is provided by pdi.vxyz
	// normal is provided as pdi.normal
	// reflect eye ray over normal to get reflected ray

	// intersect reflected ray with billboards
	// if multiple intersections, keep closest one
	// if no intersections, lookup reflected ray in environment mapping
	// billboard is passed in as uniform parameter, e.g. float4x4
	// EXTRA CREDIT: environment mapping is a uniform input parameter "cube sampler or something like that"

	// SOFT SHADOWS CAST BY RECTANGULAR LIGHT SOURCE
	// for all light sample rows
	//		for all light samples in current row
	//			define light ray = light sample - 3D surface point
	//			intersect light ray with all box faces
	//			if no intersection, increment fragment light counter
}
